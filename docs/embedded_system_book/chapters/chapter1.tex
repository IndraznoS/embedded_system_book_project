\chapter{Introduction To VHDL}

\section{VHDL}
The VHDL entity construct provides a method to abstract the functionality of a circuit description to a higher level. It provides a simple wrapper for the lower-level circuitry. This wrapper effectively describes how the black box interfaces with the outside world. Since VHDL describes digital circuits, the entity simply lists the various inputs and outputs of the underlying circuitry. In VHDL terms, the black box is described by an entity declaration. The syntax of the entity declaration is shown in Listing~\ref{entity_basic}.

\noindent
\begin{minipage}{0.99\linewidth}
    \begin{lstlisting}[style=VHDLStyle, label=entity_basic, caption=The entity declaration in VHDL., mathescape=true]
entity my_entity is
port(
    port_name_1 : in    std_logic ;
    port_name_2 : out   std_logic;
    port_name_3 : inout std_logic ); --do not forget the semicolon
end my_entity; -- do not forget this semicolon either
\end{lstlisting}
\end{minipage}

\texttt{my\_entity} defines the name of the entity. The next section is nothing more than the list of signals from the underlying circuit that are available to the outside world, which is why it is often referred to as an interface specification. The \texttt{port\_name\_x} is an identifier used to differentiate the various signals. The next keyword (the keyword \texttt{in}) specifies the direction of the signal relative to the entity where signals can either enter, exit or do both. These input and output signals are associated with the keywords \textbf{in}, \textbf{out} and \textbf{inout}\footnote{The \texttt{inout} data mode will be discussed later on in the book.} respectively. The next keyword (the keyword \texttt{std\_logic}) refers to the type of data that the port will handle. There are several data types available in VHDL but we will primarily deal with the \texttt{std\_logic} type and derived versions. More information regarding the various VHDL data types will be discussed later.

\section{Tikz Picture}
\begin{figure}
    \centering
    \begin{tikzpicture}[x=1mm,y=1mm,line width=0.8pt,scale=0.9,framed]
        %\draw[help lines] (0,0) grid (50,50);
        % BOX
        \draw (20,0) rectangle (37,35) node[midway]{killer\_ckt};
        % INPUTS
        \small
        \node (a) at (20,-2.5) {}; % this is the reference point
        \draw [latex-] ($(a)+(0,25)$) -- ++(-10,0) node[left]{life\_in1};
        \draw [latex-] ($(a)+(0,20)$) -- ++(-10,0) node[left]{life\_in2};
        \draw [latex-] ($(a)+(0,15)$) -- ++(-10,0) node[left]{ctrl\_a};
        \draw [latex-] ($(a)+(0,10)$) -- ++(-10,0) node[left]{ctrl\_b};
        % OUTPUTS
        \draw [-latex] ($(a)+(17,25)$) -- ++(10,0) node[right]{kill\_a};
        \draw [-latex] ($(a)+(17,20)$) -- ++(10,0) node[right]{kill\_b};
        \draw [-latex] ($(a)+(17,15)$) -- ++(10,0) node[right]{kill\_c};
    \end{tikzpicture}
    \caption{Diagram Sederhana Killer Circuit}
    \label{fig:killer-ckt}
\end{figure}

% \begin{minipage}{0.49\linewidth}
%     \begin{flushright}
%         \begin{tikzpicture}[x=1mm,y=1mm,line width=0.8pt,scale=0.9,framed]
%             %\draw[help lines] (0,0) grid (50,50);
%             % BOX
%             \draw (20,0) rectangle (37,35) node[midway]{killer\_ckt};
%             % INPUTS
%             \small
%             \node (a) at (20,-2.5) {}; % this is the reference point
%             \draw [latex-] ($(a)+(0,25)$) -- ++(-10,0) node[left]{life\_in1};
%             \draw [latex-] ($(a)+(0,20)$) -- ++(-10,0) node[left]{life\_in2};
%             \draw [latex-] ($(a)+(0,15)$) -- ++(-10,0) node[left]{ctrl\_a};
%             \draw [latex-] ($(a)+(0,10)$) -- ++(-10,0) node[left]{ctrl\_b};
%             % OUTPUTS
%             \draw [-latex] ($(a)+(17,25)$) -- ++(10,0) node[right]{kill\_a};
%             \draw [-latex] ($(a)+(17,20)$) -- ++(10,0) node[right]{kill\_b};
%             \draw [-latex] ($(a)+(17,15)$) -- ++(10,0) node[right]{kill\_c};
%         \end{tikzpicture}
%     \end{flushright}

% \end{minipage}

\section{Arduino Code}

\begin{minipage}{0.99\linewidth}
    \begin{lstlisting}[style=ArduinoStyle,caption={Program OLED Minimalis},label={lst:oled-simple}]
#include <Wire.h>
#include <SSD1306Wire.h>

// Inisialisasi OLED: alamat I2C, SDA, SCL
SSD1306Wire display(0x3c, 18, 17);

void setup() {
    display.init();
    display.flipScreenVertically(); // T3-S3 memiliki orientasi terbalik
    display.setFont(ArialMT_Plain_10);
    display.clear();
    display.drawString(0, 0, "Halo Dunia!");
    display.drawString(0, 12, "LILYGO T3-S3");
    display.display(); // Penting: tanpa ini, layar tetap kosong
}

void loop() {
  // Tidak ada pembaruan dinamis
}
\end{lstlisting}
\end{minipage}

\section{PHP Code}
\begin{minipage}{0.99\linewidth}
    \begin{lstlisting}[style=PHPStyle,caption={Endpoint PHP Minimalis},label={lst:php-simple}]
<?php
echo "Halo dari Server!";
?>
\end{lstlisting}
\end{minipage}


\section{Javascript}
\begin{minipage}{0.99\linewidth}
    \begin{lstlisting}[style=JavaScriptStyle,caption={Javascript Minimalis},label={lst:js-simple}]
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0    ">
    <title>Document</title>
</head>
<body>
    <h1 id="greeting">Hello, World!</h1>
    <button onclick="changeGreeting()">Click Me</button>

    <script>
        function changeGreeting() {
            document.getElementById("greeting").innerText = "Hello, JavaScript!";
        }
    </script>
</body>
</html>
\end{lstlisting}
\end{minipage}

\section{PYTHON}
\begin{minipage}{0.99\linewidth}
    \begin{lstlisting}[style=PythonStyle,caption={Python Minimalis},label={lst:python-simple}]
        print("Halo, Dunia!")
    \end{lstlisting}
\end{minipage}

\section{ESP32}
\begin{minipage}{0.99\linewidth}
    \lstinputlisting[
        style=ArduinoStyle,
        caption={Blink example for ESP32},
        label={lst:esp32_blink}
    ]{../../arduino/esp32-devkit/blink/src/main.ino}
\end{minipage}


\section{Fade}
\begin{minipage}{0.99\linewidth}
    \lstinputlisting[
        style=ArduinoStyle,
        caption={Fade example for ESP32},
        label={lst:esp32_fade}
    ]{../../arduino/esp32-devkit/LEDCFade/LEDCFade.ino}
\end{minipage}

\section{Penjelasan Program Fade LED Menggunakan LEDC pada ESP32}

Program ini mengimplementasikan efek \textit{fade in} dan \textit{fade out} pada LED yang terhubung ke pin GPIO ESP32 menggunakan fitur \texttt{LEDC} (LED PWM Controller). Berikut penjelasan bagian per bagian:

\begin{verbatim}
// use 12 bit precision for LEDC timer
#define LEDC_TIMER_12_BIT 12
\end{verbatim}
\begin{enumerate}
    \item Mendefinisikan resolusi timer LEDC sebesar 12 bit. Artinya, nilai \textit{duty cycle} dapat berkisar antara 0 hingga \(2^{12} - 1 = 4095\).
\end{enumerate}

\begin{verbatim}
// use 5000 Hz as a LEDC base frequency
#define LEDC_BASE_FREQ 5000
\end{verbatim}
\begin{enumerate}
    \item Menetapkan frekuensi dasar PWM sebesar 5000 Hz. Frekuensi ini cukup tinggi sehingga manusia tidak dapat melihat kedipan LED, menghasilkan cahaya yang tampak mulus.
\end{enumerate}

\begin{verbatim}
// fade LED PIN (replace with LED_BUILTIN constant for built-in LED)
#define LED_PIN 4
\end{verbatim}
\begin{enumerate}
    \item Menentukan pin GPIO tempat LED terhubung, dalam hal ini pin 4. Pengguna dapat menggantinya dengan \texttt{LED\_BUILTIN} jika menggunakan LED bawaan papan.
\end{enumerate}

\begin{verbatim}
// define starting duty, target duty and maximum fade time
#define LEDC_START_DUTY  (0)
#define LEDC_TARGET_DUTY (4095)
#define LEDC_FADE_TIME   (3000)
\end{verbatim}
\begin{enumerate}
    \item \texttt{LEDC\_START\_DUTY}: Nilai awal \textit{duty cycle} (0 = mati).
    \item \texttt{LEDC\_TARGET\_DUTY}: Nilai akhir \textit{duty cycle} (4095 = nyala penuh).
    \item \texttt{LEDC\_FADE\_TIME}: Durasi transisi \textit{fade} dalam milidetik (3000 ms = 3 detik).
\end{enumerate}

\begin{verbatim}
bool fade_ended = false;  // status of LED fade
bool fade_in = true;
\end{verbatim}
\begin{enumerate}
    \item \texttt{fade\_ended}: Bendera untuk menandai apakah proses \textit{fade} telah selesai, diatur oleh \textit{interrupt service routine} (ISR).
    \item \texttt{fade\_in}: Bendera untuk menentukan arah \textit{fade} berikutnya (\texttt{true} = \textit{fade in}, \texttt{false} = \textit{fade out}).
\end{enumerate}

\begin{verbatim}
void ARDUINO_ISR_ATTR LED_FADE_ISR() {
  fade_ended = true;
}
\end{verbatim}
\begin{enumerate}
    \item Fungsi ISR yang dipanggil otomatis oleh perangkat keras ketika proses \textit{fade} selesai.
    \item Atribut \texttt{ARDUINO\_ISR\_ATTR} memastikan fungsi ini kompatibel dengan lingkungan ISR Arduino pada ESP32.
    \item Fungsi ini hanya mengatur \texttt{fade\_ended = true} untuk memberi tahu \texttt{loop()} bahwa transisi telah selesai.
\end{enumerate}

\begin{verbatim}
void setup() {
  // Initialize serial communication at 115200 bits per second:
  Serial.begin(115200);

  // Setup timer with given frequency, resolution and attach it to a led pin with auto-selected channel
  ledcAttach(LED_PIN, LEDC_BASE_FREQ, LEDC_TIMER_12_BIT);

  // Setup and start fade on led (duty from 0 to 4095)
  ledcFade(LED_PIN, LEDC_START_DUTY, LEDC_TARGET_DUTY, LEDC_FADE_TIME);
  Serial.println("LED Fade on started.");

  // Wait for fade to end
  delay(LEDC_FADE_TIME);

  // Setup and start fade off led and use ISR (duty from 4095 to 0)
  ledcFadeWithInterrupt(LED_PIN, LEDC_TARGET_DUTY, LEDC_START_DUTY, LEDC_FADE_TIME, LED_FADE_ISR);
  Serial.println("LED Fade off started.");
}
\end{verbatim}
\begin{enumerate}
    \item \texttt{Serial.begin(115200)}: Menginisialisasi komunikasi serial untuk debugging.
    \item \texttt{ledcAttach(...) }: Mengonfigurasi kanal LEDC secara otomatis pada \texttt{LED\_PIN} dengan frekuensi dan resolusi yang ditentukan.
    \item \texttt{ledcFade(...) }: Memulai transisi \textit{fade in} tanpa ISR; program menunggu secara blok menggunakan \texttt{delay()} selama durasi \textit{fade}.
    \item Setelah \textit{fade in} selesai, program memulai \textit{fade out} menggunakan \texttt{ledcFadeWithInterrupt(...)}, yang memungkinkan ISR dipanggil saat selesai, sehingga eksekusi tidak perlu diblokir.
\end{enumerate}




\begin{lstlisting}[
  basicstyle=\ttfamily\scriptsize,
  breaklines=true,
  breakatwhitespace=false, % crucial: allows breaking at commas/symbols
  postbreak=\mbox{\textcolor{red}{\tiny$\hookrightarrow$}\space}
]
void loop() {
  // Check if fade_ended flag was set to true in ISR
  if (fade_ended) {
    Serial.println("LED fade ended");
    fade_ended = false;

    // Check what fade should be started next
    if (fade_in) {
      ledcFadeWithInterrupt(LED_PIN, LEDC_START_DUTY, LEDC_TARGET_DUTY, LEDC_FADE_TIME, 
      LED_FADE_ISR);
      Serial.println("LED Fade in started.");
      fade_in = false;
    } else {
      ledcFadeWithInterrupt(LED_PIN, LEDC_TARGET_DUTY, LEDC_START_DUTY, LEDC_FADE_TIME, LED_FADE_ISR);
      Serial.println("LED Fade out started.");
      fade_in = true;
    }
  }
}
\end{lstlisting}


\begin{enumerate}
    \item Di dalam \texttt{loop()}, program memeriksa apakah \texttt{fade\_ended} bernilai \texttt{true}.
    \item Jika ya, program mencetak pesan, mereset bendera, lalu memulai \textit{fade} berikutnya sesuai arah yang ditentukan oleh \texttt{fade\_in}.
    \item Transisi selanjutnya selalu menggunakan \texttt{ledcFadeWithInterrupt}, sehingga sistem tetap responsif dan tidak terblokir oleh \texttt{delay()}.
    \item Nilai \texttt{fade\_in} diubah setiap kali transisi selesai, menciptakan siklus berulang \textit{fade in} $\leftrightarrow$ \textit{fade out}.
\end{enumerate}

Secara keseluruhan, program ini menunjukkan penggunaan efisien fitur LEDC ESP32 untuk menghasilkan efek PWM halus dengan dukungan \textit{hardware-accelerated fading} dan penanganan berbasis interupsi.
